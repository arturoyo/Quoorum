/**
 * Advanced Analytics
 * 
 * Comprehensive analytics and metrics for debates
 */

import type { DebateResult } from './types'

// ============================================================================
// TYPES
// ============================================================================

export interface DebateMetrics {
  totalDebates: number
  completedDebates: number
  failedDebates: number
  avgConsensusScore: number
  avgQualityScore: number
  avgDuration: number // seconds
  avgCost: number // USD
  totalCost: number // USD
  avgRounds: number
  topExperts: Array<{ name: string; participations: number; avgQuality: number }>
  topCategories: Array<{ category: string; count: number }>
  consensusDistribution: {
    high: number // 90%+
    medium: number // 70-90%
    low: number // <70%
  }
  timeDistribution: {
    morning: number // 6-12
    afternoon: number // 12-18
    evening: number // 18-24
    night: number // 0-6
  }
}

export interface UserAnalytics {
  userId: string
  period: { start: Date; end: Date }
  metrics: DebateMetrics
  trends: {
    debatesPerDay: number
    consensusTrend: number // % change
    costTrend: number // % change
    qualityTrend: number // % change
  }
  topQuestions: Array<{ question: string; consensus: number; date: Date }>
  costBreakdown: {
    byCategory: Record<string, number>
    byMonth: Record<string, number>
  }
}

export interface AdminDashboard {
  overview: {
    totalUsers: number
    activeUsers: number // last 30 days
    totalDebates: number
    debatesToday: number
    totalCost: number
    costToday: number
    avgConsensus: number
    avgQuality: number
  }
  growth: {
    usersGrowth: number // % change
    debatesGrowth: number // % change
    revenueGrowth: number // % change (if applicable)
  }
  topUsers: Array<{
    userId: string
    debateCount: number
    totalCost: number
    avgConsensus: number
  }>
  systemHealth: {
    avgResponseTime: number
    errorRate: number
    cacheHitRate: number
    queueLength: number
  }
}

// ============================================================================
// METRICS CALCULATION
// ============================================================================

export function calculateDebateMetrics(debates: DebateResult[]): DebateMetrics {
  if (debates.length === 0) {
    return {
      totalDebates: 0,
      completedDebates: 0,
      failedDebates: 0,
      avgConsensusScore: 0,
      avgQualityScore: 0,
      avgDuration: 0,
      avgCost: 0,
      totalCost: 0,
      avgRounds: 0,
      topExperts: [],
      topCategories: [],
      consensusDistribution: { high: 0, medium: 0, low: 0 },
      timeDistribution: { morning: 0, afternoon: 0, evening: 0, night: 0 },
    }
  }

  const completed = debates.filter(d => d.consensusScore !== undefined)
  const failed = debates.length - completed.length

  // Basic metrics
  const avgConsensusScore =
    completed.reduce((sum, d) => sum + d.consensusScore, 0) / completed.length

  const avgQualityScore =
    completed.reduce((sum, d) => sum + (d.qualityScore || 0), 0) / completed.length

  const avgDuration =
    completed.reduce((sum, d) => sum + (d.duration || 0), 0) / completed.length

  const totalCost = completed.reduce((sum, d) => sum + (d.totalCost || 0), 0)
  const avgCost = totalCost / completed.length

  const avgRounds =
    completed.reduce((sum, d) => sum + (d.rounds?.length || 0), 0) / completed.length

  // Expert participation
  const expertStats = new Map<string, { count: number; totalQuality: number }>()
  for (const debate of completed) {
    if (!debate.participants) continue
    for (const expert of debate.participants) {
      const stats = expertStats.get(expert.name) || { count: 0, totalQuality: 0 }
      stats.count++
      stats.totalQuality += debate.qualityScore || 0
      expertStats.set(expert.name, stats)
    }
  }

  const topExperts = Array.from(expertStats.entries())
    .map(([name, stats]) => ({
      name,
      participations: stats.count,
      avgQuality: stats.totalQuality / stats.count,
    }))
    .sort((a, b) => b.participations - a.participations)
    .slice(0, 10)

  // Category distribution
  const categoryStats = new Map<string, number>()
  for (const debate of completed) {
    const category = debate.category || 'Other'
    categoryStats.set(category, (categoryStats.get(category) || 0) + 1)
  }

  const topCategories = Array.from(categoryStats.entries())
    .map(([category, count]) => ({ category, count }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10)

  // Consensus distribution
  const consensusDistribution = {
    high: completed.filter(d => d.consensusScore >= 0.9).length,
    medium: completed.filter(d => d.consensusScore >= 0.7 && d.consensusScore < 0.9).length,
    low: completed.filter(d => d.consensusScore < 0.7).length,
  }

  // Time distribution (would need createdAt timestamps)
  const timeDistribution = {
    morning: 0,
    afternoon: 0,
    evening: 0,
    night: 0,
  }

  return {
    totalDebates: debates.length,
    completedDebates: completed.length,
    failedDebates: failed,
    avgConsensusScore,
    avgQualityScore,
    avgDuration,
    avgCost,
    totalCost,
    avgRounds,
    topExperts,
    topCategories,
    consensusDistribution,
    timeDistribution,
  }
}

// ============================================================================
// USER ANALYTICS
// ============================================================================

export function calculateUserAnalytics(
  userId: string,
  debates: DebateResult[],
  period: { start: Date; end: Date }
): UserAnalytics {
  const metrics = calculateDebateMetrics(debates)

  // Calculate trends (compare with previous period)
  const periodDays = Math.ceil(
    (period.end.getTime() - period.start.getTime()) / (1000 * 60 * 60 * 24)
  )
  const debatesPerDay = debates.length / periodDays

  // For trends, would need historical data
  const trends = {
    debatesPerDay,
    consensusTrend: 0,
    costTrend: 0,
    qualityTrend: 0,
  }

  // Top questions
  const topQuestions = debates
    .filter(d => d.consensusScore >= 0.7)
    .sort((a, b) => b.consensusScore - a.consensusScore)
    .slice(0, 10)
    .map(d => ({
      question: d.question,
      consensus: d.consensusScore,
      date: new Date(), // Would use actual createdAt
    }))

  // Cost breakdown
  const costByCategory: Record<string, number> = {}
  const costByMonth: Record<string, number> = {}

  for (const debate of debates) {
    const category = debate.category || 'Other'
    costByCategory[category] = (costByCategory[category] || 0) + (debate.totalCost || 0)

    // Month would come from createdAt
    const month = new Date().toISOString().slice(0, 7)
    costByMonth[month] = (costByMonth[month] || 0) + (debate.totalCost || 0)
  }

  return {
    userId,
    period,
    metrics,
    trends,
    topQuestions,
    costBreakdown: {
      byCategory: costByCategory,
      byMonth: costByMonth,
    },
  }
}

// ============================================================================
// ADMIN DASHBOARD
// ============================================================================

export function generateAdminDashboard(
  allDebates: DebateResult[],
  userDebates: Map<string, DebateResult[]>
): AdminDashboard {
  const today = new Date()
  today.setHours(0, 0, 0, 0)

  const debatesToday = allDebates.filter(d => {
    // Would use actual createdAt
    return true
  }).length

  const totalCost = allDebates.reduce((sum, d) => sum + (d.totalCost || 0), 0)
  const costToday = 0 // Would calculate from today's debates

  const metrics = calculateDebateMetrics(allDebates)

  // Top users
  const topUsers = Array.from(userDebates.entries())
    .map(([userId, debates]) => {
      const userMetrics = calculateDebateMetrics(debates)
      return {
        userId,
        debateCount: debates.length,
        totalCost: userMetrics.totalCost,
        avgConsensus: userMetrics.avgConsensusScore,
      }
    })
    .sort((a, b) => b.debateCount - a.debateCount)
    .slice(0, 10)

  return {
    overview: {
      totalUsers: userDebates.size,
      activeUsers: userDebates.size, // Would filter by last 30 days
      totalDebates: allDebates.length,
      debatesToday,
      totalCost,
      costToday,
      avgConsensus: metrics.avgConsensusScore,
      avgQuality: metrics.avgQualityScore,
    },
    growth: {
      usersGrowth: 0, // Would calculate from historical data
      debatesGrowth: 0,
      revenueGrowth: 0,
    },
    topUsers,
    systemHealth: {
      avgResponseTime: 0, // Would track from actual requests
      errorRate: 0,
      cacheHitRate: 0,
      queueLength: 0,
    },
  }
}

// ============================================================================
// COST TRACKING
// ============================================================================

export interface CostBreakdown {
  total: number
  byModel: Record<string, number>
  byOperation: Record<string, number>
  byUser: Record<string, number>
  byDate: Record<string, number>
}

export function trackCost(
  operation: string,
  model: string,
  tokens: number,
  userId: string
): number {
  // Pricing per 1M tokens (as of 2024)
  const pricing: Record<string, { input: number; output: number }> = {
    'gpt-4o': { input: 2.5, output: 10.0 },
    'gpt-4o-mini': { input: 0.15, output: 0.6 },
    'gpt-4-turbo': { input: 10.0, output: 30.0 },
    'gpt-3.5-turbo': { input: 0.5, output: 1.5 },
  }

  const modelPricing = pricing[model] || pricing['gpt-4o-mini']
  
  // Assume 50/50 input/output split
  const cost = (tokens / 1_000_000) * ((modelPricing.input + modelPricing.output) / 2)

  // Would store in database
  console.log(`Cost tracked: ${operation} - ${model} - ${tokens} tokens - $${cost.toFixed(4)}`)

  return cost
}

export function calculateCostBreakdown(debates: DebateResult[]): CostBreakdown {
  const breakdown: CostBreakdown = {
    total: 0,
    byModel: {},
    byOperation: {},
    byUser: {},
    byDate: {},
  }

  for (const debate of debates) {
    const cost = debate.totalCost || 0
    breakdown.total += cost

    // By model (would need to track which model was used)
    const model = 'gpt-4o-mini'
    breakdown.byModel[model] = (breakdown.byModel[model] || 0) + cost

    // By operation
    const operation = 'debate'
    breakdown.byOperation[operation] = (breakdown.byOperation[operation] || 0) + cost

    // By user (would need userId)
    const userId = 'user-1'
    breakdown.byUser[userId] = (breakdown.byUser[userId] || 0) + cost

    // By date
    const date = new Date().toISOString().split('T')[0]
    breakdown.byDate[date] = (breakdown.byDate[date] || 0) + cost
  }

  return breakdown
}

// ============================================================================
// USAGE METRICS
// ============================================================================

export interface UsageMetrics {
  period: { start: Date; end: Date }
  debates: {
    total: number
    completed: number
    failed: number
    avgPerDay: number
  }
  users: {
    total: number
    active: number
    new: number
    returning: number
  }
  costs: {
    total: number
    avgPerDebate: number
    avgPerUser: number
  }
  performance: {
    avgDuration: number
    avgQuality: number
    avgConsensus: number
  }
}

export function calculateUsageMetrics(
  debates: DebateResult[],
  period: { start: Date; end: Date }
): UsageMetrics {
  const metrics = calculateDebateMetrics(debates)
  
  const periodDays = Math.ceil(
    (period.end.getTime() - period.start.getTime()) / (1000 * 60 * 60 * 24)
  )

  return {
    period,
    debates: {
      total: metrics.totalDebates,
      completed: metrics.completedDebates,
      failed: metrics.failedDebates,
      avgPerDay: metrics.totalDebates / periodDays,
    },
    users: {
      total: 0, // Would count unique users
      active: 0,
      new: 0,
      returning: 0,
    },
    costs: {
      total: metrics.totalCost,
      avgPerDebate: metrics.avgCost,
      avgPerUser: 0,
    },
    performance: {
      avgDuration: metrics.avgDuration,
      avgQuality: metrics.avgQualityScore,
      avgConsensus: metrics.avgConsensusScore,
    },
  }
}

// ============================================================================
// EXPORT
// ============================================================================

export function exportAnalyticsReport(
  analytics: UserAnalytics | AdminDashboard,
  format: 'json' | 'csv'
): string {
  if (format === 'json') {
    return JSON.stringify(analytics, null, 2)
  }

  // CSV export (simplified)
  if ('overview' in analytics) {
    // Admin dashboard
    const lines = [
      'Metric,Value',
      `Total Users,${analytics.overview.totalUsers}`,
      `Active Users,${analytics.overview.activeUsers}`,
      `Total Debates,${analytics.overview.totalDebates}`,
      `Total Cost,$${analytics.overview.totalCost.toFixed(2)}`,
      `Avg Consensus,${(analytics.overview.avgConsensus * 100).toFixed(1)}%`,
    ]
    return lines.join('\n')
  } else {
    // User analytics
    const lines = [
      'Metric,Value',
      `Total Debates,${analytics.metrics.totalDebates}`,
      `Avg Consensus,${(analytics.metrics.avgConsensusScore * 100).toFixed(1)}%`,
      `Total Cost,$${analytics.metrics.totalCost.toFixed(2)}`,
      `Avg Quality,${(analytics.metrics.avgQualityScore * 100).toFixed(1)}%`,
    ]
    return lines.join('\n')
  }
}
